<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Calendar (Tailwind Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style type="text/tailwindcss">
        /* 1. 기본 셀 스타일 */
        td.is-in-range { @apply bg-blue-100; }
        
        /* 2. 날짜 버튼 스타일 */
        .day-btn {
            @apply w-9 h-9 flex items-center justify-center rounded-full mx-auto transition-colors duration-150 relative;
            flex-direction: column; line-height: 1; padding-top: 4px; cursor: pointer;
        }
        .day-btn:focus-visible { @apply ring-2 ring-offset-2 ring-blue-500 outline-none z-10; }
        .day-btn:not(:disabled):hover { @apply bg-gray-100; }
        
        /* 상태별 색상 */
        .day-btn.is-sun { @apply text-red-500; }
        .day-btn.is-today { @apply border border-gray-400; }
        
        /* 비활성화 스타일 */
        .day-btn:disabled, 
        td.is-disabled .day-btn { 
            @apply text-gray-300 cursor-not-allowed line-through opacity-50; 
            pointer-events: none; 
        }
        
        /* 선택된 날짜 스타일 */
        td.is-start-date .day-btn,
        td.is-end-date .day-btn,
        td.is-single-date .day-btn { 
            @apply bg-blue-600 text-white font-semibold;
            opacity: 1 !important;
        }

        /* 둥근 모서리 */
        td.is-range-start { @apply rounded-l-lg; }
        td.is-range-end { @apply rounded-r-lg; }

        /* '오늘' 레이블 */
        .today-label { 
            position: absolute; bottom: 2px; font-size: 0.5rem; font-weight: 500; color: inherit; 
        }
        td.is-start-date .today-label, td.is-end-date .today-label, td.is-single-date .today-label { color: white; }

        /* 월 경계 마커 (그라데이션) */
        td.range-end-marker { background: linear-gradient(to right, #dbeafe 50%, transparent 50%); }
        td.range-start-marker { background: linear-gradient(to left, #dbeafe 50%, transparent 50%); }

        /* 애니메이션 */
        .calendar-slider { transition: transform 0.3s ease-in-out; }

        /* [예제용] 커스텀 뱃지 스타일 */
        .price-badge { position: absolute; top: -2px; right: -2px; width: 6px; height: 6px; background: #ef4444; border-radius: 50%; }
    </style>
</head>
<body class="p-10 bg-gray-100">

    <div class="max-w-lg mx-auto bg-white p-6 rounded-xl shadow-lg">
        <h2 class="text-xl font-bold mb-4">테일윈드 적용 확인</h2>
        
        <div class="p-4 border border-gray-300 rounded bg-white mb-4">
            <div class="flex space-x-2">
                <div class="w-1/2">
                    <label class="block text-xs text-gray-500 mb-1">시작일</label>
                    <input id="start-date-input" class="w-full border p-2 rounded text-center font-medium" value="2025-11-28" />
                </div>
                <div class="w-1/2">
                    <label class="block text-xs text-gray-500 mb-1">종료일</label>
                    <input id="end-date-input" class="w-full border p-2 rounded text-center font-medium" value="2026-08-05" /> 
                </div>
            </div>
        </div>

        <div id="calendar-root" aria-live="polite"></div>
    </div>

<script>
    // ============================================
    //  ⬇️ CalendarLib Core ⬇️
    // ============================================

    function CalendarLib(element, options) {
        if (!element) return;
        this.element = element;
        options = options || {};
        this.options = {
            numberOfMonths: options.numberOfMonths, 
            selectionMode: options.selectionMode || 'RANGE',
            startDateSelector: options.startDateSelector || null, endDateSelector: options.endDateSelector || null, 
            format: options.format || 'YYYY.MM.DD(ddd)', 
            defaultStartLabel: options.defaultStartLabel || '가는날', defaultEndLabel: options.defaultEndLabel || '오는날',
            swipeNavigation: options.swipeNavigation || false, rangeClass: options.rangeClass || null,
            disable: options.disable || [], enable: options.enable || [],
            startDate: options.startDate || null, endDate: options.endDate || null,
            selectableDays: options.selectableDays || null, 
            minDate: options.minDate !== undefined ? options.minDate : 'today', 
            maxDate: options.maxDate || null,
            onSelect: options.onSelect || null,
            onInvalid: options.onInvalid || null,
            onMonthChange: options.onMonthChange || null,
            onRenderCell: options.onRenderCell || null
        };
        this.els = {
            startInput: this.options.startDateSelector ? document.querySelector(this.options.startDateSelector) : null,
            endInput: (this.options.selectionMode === 'RANGE' && this.options.endDateSelector) ? document.querySelector(this.options.endDateSelector) : null
        };
        this.isSingleMode = (this.options.selectionMode === 'SINGLE');
        this.startDate = null; this.endDate = null;
        this.today = new Date(); this.today.setHours(0, 0, 0, 0);
        this.minLimit = null; this.maxLimit = null;
        
        this.monthData = []; this.currentMonthIndex = 0; 
        this.allDayBtns = []; this.cachedMarkerTds = [];
        this.isEventBound = false;

        this.init();
    }

    CalendarLib.prototype.init = function() {
        var initialStartISO = this.options.startDate || null; 
        var initialEndISO = (!this.isSingleMode && this.options.endDate) ? this.options.endDate : null;
        
        if (!initialStartISO && this.els.startInput) { initialStartISO = this._parseDisplayDate(this.els.startInput.value); }
        if (!initialEndISO && this.els.endInput) { initialEndISO = this._parseDisplayDate(this.els.endInput.value); }

        if (this.options.minDate === 'today') { this.minLimit = new Date(this.today.getTime()); } 
        else if (this.options.minDate) { this.minLimit = this._parseDate(this._parseDisplayDate(this.options.minDate)); } 
        
        if (this.options.maxDate) { this.maxLimit = this._parseDate(this._parseDisplayDate(this.options.maxDate)); }
        if (this.minLimit) this.minLimit.setHours(0,0,0,0); if (this.maxLimit) this.maxLimit.setHours(0,0,0,0);

        var startObj = initialStartISO ? this._parseDate(initialStartISO) : null;
        var renderBaseDate = startObj ? new Date(startObj.getTime()) : (this.minLimit ? new Date(this.minLimit.getTime()) : new Date(this.today.getTime()));
        if (this.minLimit && renderBaseDate < this.minLimit) renderBaseDate = new Date(this.minLimit.getTime());

        var startYear = renderBaseDate.getFullYear();
        var startMonth = renderBaseDate.getMonth() + 1;

        if (!this.options.numberOfMonths) {
            var neededMonths = 2;
            if (initialEndISO) {
                var endDateObj = this._parseDate(initialEndISO);
                if (endDateObj) {
                    var diff = (endDateObj.getFullYear() * 12 + endDateObj.getMonth()) - (startYear * 12 + (startMonth - 1)) + 1;
                    neededMonths = Math.max(neededMonths, diff);
                }
            }
            this.options.numberOfMonths = neededMonths;
        }

        this.element.innerHTML = '';
        if (this.options.swipeNavigation) { 
            this._buildSwipeStructure(startYear, startMonth); 
            this.currentMonthIndex = 0; 
        } else { 
            this._buildScrollStructure(startYear, startMonth); 
        }

        this.allDayBtns = this.element.querySelectorAll('.day-btn');
        this.cachedMarkerTds = this.element.querySelectorAll('[data-marker-type]');

        if (!this.isEventBound) {
            this.element.addEventListener('click', this._handleDayClick.bind(this));
            this.isEventBound = true;
        }
        
        this.setRange(initialStartISO, initialEndISO);
        this._triggerRenderCell();
    };

    CalendarLib.prototype._triggerRenderCell = function() {
        if (typeof this.options.onRenderCell === 'function') {
            for (var i = 0; i < this.allDayBtns.length; i++) {
                var btn = this.allDayBtns[i];
                var d = this._parseDate(btn.dataset.date);
                var cell = btn.parentNode;
                this.options.onRenderCell(d, cell);
            }
        }
    };

    CalendarLib.prototype._isDateDisabled = function(dateObj, dateStr) {
        if (this.minLimit && dateObj.getTime() < this.minLimit.getTime()) return true;
        if (this.maxLimit && dateObj.getTime() > this.maxLimit.getTime()) return true;
        if (this.options.enable && this.options.enable.length > 0) return this.options.enable.indexOf(dateStr) === -1;
        if (this.options.disable && this.options.disable.length > 0) return this.options.disable.indexOf(dateStr) !== -1;
        return false;
    };

    CalendarLib.prototype._generateCalendarHTML = function(year, month) {
        var monthIndex = month - 1; var firstDay = new Date(year, monthIndex, 1);
        var daysInMonth = new Date(year, month, 0).getDate();
        var startDayOfWeek = firstDay.getDay(); 
        
        var html = '<div class="month-grid">' + 
            '<h3 class="mb-2 text-base font-semibold text-center" id="month-'+year+'-'+month+'">' + year + '년 ' + month + '월</h3>' +
            '<table class="w-full text-center table-auto border-collapse" role="grid" aria-labelledby="month-'+year+'-'+month+'">' +
                '<thead><tr class="text-sm text-gray-500">' + 
                '<th scope="col" class="pb-2 font-normal text-red-500">일</th><th scope="col" class="pb-2 font-normal">월</th>' +
                '<th scope="col" class="pb-2 font-normal">화</th><th scope="col" class="pb-2 font-normal">수</th><th scope="col" class="pb-2 font-normal">목</th><th scope="col" class="pb-2 font-normal">금</th><th scope="col" class="pb-2 font-normal">토</th>' +
                '</tr></thead>' + '<tbody>';
        var dayCounter = 1; var paddingStarted = false;
        
        var firstDayOfCurrentMonth = new Date(year, monthIndex, 1); firstDayOfCurrentMonth.setHours(0,0,0,0);
        var lastDayOfCurrentMonth = new Date(year, monthIndex, daysInMonth); lastDayOfCurrentMonth.setHours(0,0,0,0);
        var firstDayISO = this._dateToISO(firstDayOfCurrentMonth);
        var lastDayISO = this._dateToISO(lastDayOfCurrentMonth);
        var dayNames = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];

        for (var i = 0; i < 6; i++) {
            html += '<tr>';
            for (var j = 0; j < 7; j++) {
                var tdClasses = ''; var classes = 'day-btn'; var extraLabel = ''; var ariaLabel = '';
                var markerAttr = '';

                if (i === 0 && j < startDayOfWeek) { 
                    if (j === startDayOfWeek - 1) { markerAttr = 'data-marker-type="prev" data-ref-date="' + firstDayISO + '"'; }
                    html += '<td class="' + tdClasses + '" ' + markerAttr + '><span aria-hidden="true"></span></td>'; continue;
                } else if (dayCounter > daysInMonth) {
                    if (!paddingStarted) { markerAttr = 'data-marker-type="next" data-ref-date="' + lastDayISO + '"'; paddingStarted = true; }
                    html += '<td class="' + tdClasses + '" ' + markerAttr + '><span aria-hidden="true"></span></td>'; dayCounter++; continue;
                } else {
                    var dateObj = new Date(year, monthIndex, dayCounter); dateObj.setHours(0,0,0,0);
                    var fullDateStr = this._dateToISO(dateObj);
                    ariaLabel = year + '년 ' + month + '월 ' + dayCounter + '일 ' + dayNames[j];

                    if (j === 0) classes += ' is-sun';
                    if (dateObj.getTime() === this.today.getTime()) { 
                        classes += ' is-today'; extraLabel = '<span class="today-label" aria-hidden="true">오늘</span>'; ariaLabel += ', 오늘';
                    }
                    
                    var isDisabled = this._isDateDisabled(dateObj, fullDateStr);
                    var disabledAttr = isDisabled ? 'disabled aria-disabled="true"' : '';
                    if (isDisabled) { tdClasses += ' is-disabled'; classes += ' is-disabled'; }
                    
                    html += '<td class="' + tdClasses + '"><button type="button" class="' + classes + '" data-date="' + fullDateStr + '" aria-label="' + ariaLabel + '" ' + disabledAttr + '>' + dayCounter + extraLabel + '</button></td>';
                    dayCounter++;
                }
            }
            html += '</tr>';
            if (dayCounter > daysInMonth) break; 
        }
        html += '</tbody></table></div>';
        return html;
    };

    CalendarLib.prototype.setRange = function(start, endOrDuration) {
        var endOr = endOrDuration !== undefined ? endOrDuration : null; 
        this.startDate = start || null; this.endDate = null;
        if (this.isSingleMode) {} else if (this.startDate) {
            if (typeof endOr === 'string') { this.endDate = endOr; } 
            else if (typeof endOr === 'number') {
                var date = this._parseDate(this.startDate); if (date) { date.setDate(date.getDate() + endOr); this.endDate = this._dateToISO(date); }
            }
            if (this.endDate) {
                var s = this._parseDate(this.startDate); var e = this._parseDate(this.endDate);
                s.setHours(0,0,0,0); e.setHours(0,0,0,0);
                if (e.getTime() <= s.getTime()) { this.endDate = null; }
            }
        } 
        this._updateUI();
    };

    CalendarLib.prototype._handleDayClick = function(e) {
        var target = e.target;
        var btn = target.closest('.day-btn');
        
        if (!btn) return; 
        if (btn.disabled) {
             if(typeof this.options.onInvalid === 'function') { this.options.onInvalid(btn.dataset.date); }
             return; 
        }
        
        var clickedDate = btn.dataset.date;
        
        if (this.isSingleMode) {
            this.startDate = clickedDate; this.endDate = null;
        } else {
            if (this.startDate && this.endDate) { 
                this.startDate = clickedDate; this.endDate = null; 
            } else if (this.startDate && !this.endDate) {
                var sDate = this._parseDate(this.startDate);
                var cDate = this._parseDate(clickedDate);
                if (cDate.getTime() <= sDate.getTime()) {
                    this.startDate = clickedDate; this.endDate = null; 
                } else { this.endDate = clickedDate; }
            } else { this.startDate = clickedDate; }
        }
        this._updateUI();
        
        if(typeof this.options.onSelect === 'function') { this.options.onSelect(this.getValue()); }
    };

    CalendarLib.prototype._updateUI = function() {
        var start = this.startDate ? this._parseDate(this.startDate) : null; 
        var end = this.endDate ? this._parseDate(this.endDate) : null; 
        var customClass = this.options.rangeClass;
        
        var allBtns = (this.allDayBtns && this.allDayBtns.length > 0) ? this.allDayBtns : this.element.querySelectorAll('.day-btn');
        
        for (var i = 0; i < allBtns.length; i++) {
            var btn = allBtns[i]; 
            var dayDateStr = btn.dataset.date; if (!dayDateStr) continue;
            var dayDate = this._parseDate(dayDateStr); var dayCell = btn.parentNode; 
            
            btn.setAttribute('aria-selected', 'false'); 
            dayCell.classList.remove('is-in-range', 'is-range-start', 'is-range-end', 'is-start-date', 'is-end-date', 'is-single-date');
            if (customClass) { dayCell.classList.remove(customClass); }

            if (dayDate.getTime() === this.today.getTime()) { btn.setAttribute('aria-current', 'date'); }

            if (this.isSingleMode) {
                if (this.startDate === dayDateStr) { 
                    dayCell.classList.add('is-single-date'); btn.setAttribute('aria-selected', 'true');
                }
            } else {
                if (start && end) {
                    if (dayDate > start && dayDate < end) { 
                        dayCell.classList.add('is-in-range'); 
                        if (customClass) { dayCell.classList.add(customClass); }
                    }
                }
                if (dayDateStr === this.startDate) { 
                    dayCell.classList.add('is-start-date'); btn.setAttribute('aria-selected', 'true'); 
                    if (end) { dayCell.classList.add('is-range-start'); } 
                } 
                if (dayDateStr === this.endDate) { 
                    dayCell.classList.add('is-end-date'); btn.setAttribute('aria-selected', 'true'); 
                    if (start) { dayCell.classList.add('is-range-end'); }
                }
            }
        } 

        var markerTds = (this.cachedMarkerTds && this.cachedMarkerTds.length > 0) ? this.cachedMarkerTds : this.element.querySelectorAll('[data-marker-type]');
        for (var k = 0; k < markerTds.length; k++) {
            var markerTd = markerTds[k];
            var type = markerTd.dataset.markerType; 
            var refDate = this._parseDate(markerTd.dataset.refDate);
            
            markerTd.classList.remove('range-start-marker', 'range-end-marker');

            if (start && end) {
                if (type === 'prev') {
                    if (start.getTime() < refDate.getTime() && end.getTime() >= refDate.getTime()) {
                        markerTd.classList.add('range-start-marker');
                    }
                } else if (type === 'next') {
                    if (start.getTime() <= refDate.getTime() && end.getTime() > refDate.getTime()) {
                        markerTd.classList.add('range-end-marker');
                    }
                }
            }
        }
        this._updateSelectorDisplays();
        this._dispatchChangeEvent();
    };

    CalendarLib.prototype._updateSelectorDisplays = function() {
        var fmt = this.options.format; var sLab = this.options.defaultStartLabel; var eLab = this.options.defaultEndLabel;
        var setVal = function(el, val, defaultText) {
            if (!el) return;
            var display = val ? this._formatDate(val, fmt) : defaultText;
            if (el.tagName === 'INPUT') { el.value = display; } else { el.textContent = display; }
            if (!val) el.classList.add('text-gray-400'); else el.classList.remove('text-gray-400');
        }.bind(this);
        setVal(this.els.startInput, this.startDate, (this.isSingleMode ? '날짜 선택' : sLab));
        if (!this.isSingleMode) { setVal(this.els.endInput, this.endDate, eLab); }
    };

    // --- Helpers ---
    CalendarLib.prototype.getValue = function() { return { startDate: this.startDate, endDate: this.endDate }; };
    CalendarLib.prototype._dispatchChangeEvent = function() {
        var event; var params = { detail: this.getValue(), bubbles: true, cancelable: true };
        try { event = new CustomEvent('calendar-change', params); } catch (e) { event = document.createEvent('CustomEvent'); event.initCustomEvent('calendar-change', true, true, this.getValue()); }
        this.element.dispatchEvent(event);
    };
    CalendarLib.prototype._parseDisplayDate = function(dateString) { 
        if (!dateString) return null; 
        var cleanDate = dateString.split('(')[0].trim().replace(/[\.\/]/g, '-'); 
        return /^\d{4}-\d{1,2}-\d{1,2}$/.test(cleanDate) ? cleanDate : null; 
    };
    CalendarLib.prototype._formatDate = function(dateString, formatString) {
        if (!dateString || !formatString) return null; var date = this._parseDate(dateString); if (!date) return null;
        var y = date.getFullYear(), m = date.getMonth() + 1, d = date.getDate(), day = ['일','월','화','수','목','금','토'][date.getDay()];
        var tokens = { YYYY: y, MM: m<10?'0'+m:m, M: m, DD: d<10?'0'+d:d, D: d, ddd: day };
        return formatString.replace(/YYYY|MM|M|DD|D|ddd/g, function(x) { return tokens[x] || x; });
    };
    CalendarLib.prototype._parseDate = function(str) { 
        if (!str) return null; var p = str.split('-'); 
        return new Date(p[0], p[1]-1, p[2]); 
    };
    CalendarLib.prototype._dateToISO = function(d) { 
        if(!d) return null; var m = d.getMonth()+1, day = d.getDate(); 
        return d.getFullYear() + '-' + (m<10?'0'+m:m) + '-' + (day<10?'0'+day:day); 
    };
    CalendarLib.prototype._buildSwipeStructure = function(startYear, startMonth) {
        var current = new Date(startYear, startMonth - 1, 1); this.monthData = [];
        for (var i = 0; i < this.options.numberOfMonths; i++) { this.monthData.push({ year: current.getFullYear(), month: current.getMonth() + 1 }); current.setMonth(current.getMonth() + 1); }
        var navHtml = '<div class="calendar-header flex items-center justify-between p-2 mb-2"><button class="nav-prev p-2 text-xl font-bold" aria-label="이전 달">&lt;</button><h3 class="month-title font-bold text-lg" aria-live="polite"></h3><button class="nav-next p-2 text-xl font-bold" aria-label="다음 달">&gt;</button></div>';
        this.element.innerHTML += navHtml;
        var viewport = document.createElement('div'); viewport.className = 'calendar-viewport overflow-hidden relative';
        var slider = document.createElement('div'); slider.className = 'calendar-slider flex';
        for (var i = 0; i < this.monthData.length; i++) {
            var m = this.monthData[i]; var html = this._generateCalendarHTML(m.year, m.month);
            var wrap = document.createElement('div'); wrap.className = 'month-container min-w-full'; 
            var tempDiv = document.createElement('div'); tempDiv.innerHTML = html;
            if(tempDiv.querySelector('h3')) tempDiv.querySelector('h3').remove();
            wrap.innerHTML = tempDiv.innerHTML; slider.appendChild(wrap);
        }
        viewport.appendChild(slider); this.element.appendChild(viewport); this._bindSwipeEvents(); this._updateNavigationTitle();
    };
    CalendarLib.prototype._buildScrollStructure = function(startYear, startMonth) {
        var current = new Date(startYear, startMonth - 1, 1); var container = document.createElement('div'); container.className = 'calendar-scroll-container space-y-4 max-h-[50vh] overflow-y-auto';
        for (var i = 0; i < this.options.numberOfMonths; i++) { container.innerHTML += this._generateCalendarHTML(current.getFullYear(), current.getMonth() + 1); current.setMonth(current.getMonth() + 1); }
        this.element.appendChild(container);
    };
    CalendarLib.prototype._bindSwipeEvents = function() {
        var self = this; var prevBtn = this.element.querySelector('.nav-prev'); var nextBtn = this.element.querySelector('.nav-next');
        prevBtn.addEventListener('click', function() { self._handleNavClick(-1); }); nextBtn.addEventListener('click', function() { self._handleNavClick(1); });
    };
    CalendarLib.prototype._handleNavClick = function(dir) {
        var next = this.currentMonthIndex + dir; if (next >= 0 && next < this.monthData.length) { 
            this.currentMonthIndex = next; this._animateSwipe(); this._updateNavigationTitle(); 
            if (this.options.onMonthChange) this.options.onMonthChange(this.monthData[next].year, this.monthData[next].month);
        }
    };
    CalendarLib.prototype._animateSwipe = function() { this.element.querySelector('.calendar-slider').style.transform = 'translateX(' + (-100 * this.currentMonthIndex) + '%)'; };
    CalendarLib.prototype._updateNavigationTitle = function() {
        var m = this.monthData[this.currentMonthIndex]; this.element.querySelector('.month-title').textContent = m.year + '년 ' + m.month + '월';
        var p = this.element.querySelector('.nav-prev'), n = this.element.querySelector('.nav-next');
        p.disabled = this.currentMonthIndex===0; n.disabled = this.currentMonthIndex===this.monthData.length-1; p.style.opacity = p.disabled?.5:1; n.style.opacity = n.disabled?.5:1;
    };


    // ============================================
    //  ⬇️ 실행 코드 ⬇️
    // ============================================
    
    var myCalendar;
    document.addEventListener('DOMContentLoaded', function() {
        myCalendar = new CalendarLib(document.getElementById('calendar-root'), {
            selectionMode: 'RANGE', 
            startDateSelector: '#start-date-input', 
            endDateSelector: '#end-date-input',
            format: 'YYYY.MM.DD(ddd)',
            swipeNavigation: false,
            minDate: '2025.11.28' // 과거 선택 허용
        });

		var date = myCalendar.getValue();

		console.log(date.startDate, date.endDate);
    });


</script>
<!--
var myCalendar = new CalendarLib(document.getElementById('calendar-wrapper'), {
    
    // --- [1] 기본 모드 설정 ---
    
    /** * 선택 모드: 'RANGE' (기간 선택) 또는 'SINGLE' (하루 선택)
     * 기본값: 'RANGE' 
     */
    selectionMode: 'RANGE',

    /** * 탐색 방식: true (좌우 화살표 스와이프), false (세로 스크롤)
     * 기본값: false
     */
    swipeNavigation: false,

    /** * 한 번에 보여줄 개월 수
     * 값을 안 쓰면(undefined) minDate ~ maxDate 또는 Input 기간에 맞춰 자동 계산됨
     * 기본값: 2 (옵션 없고, 날짜 제한도 없을 때)
     */
    numberOfMonths: 2,


    // --- [2] Input 및 표시 포맷 연결 ---

    /** 시작일이 표시될 태그의 ID (#) 또는 클래스 (.) */
    startDateSelector: '#start-input',

    /** 종료일이 표시될 태그의 ID ('RANGE' 모드일 때만 사용) */
    endDateSelector: '#end-input',

    /** * 날짜 표시 형식
     * YYYY(년), MM(01~12), M(1~12), DD(01~31), D(1~31), ddd(요일)
     * 기본값: 'YYYY.MM.DD(ddd)'
     */
    format: 'YYYY년 M월 D일 (ddd)',

    /** 시작일이 없을 때 인풋에 보여줄 기본 텍스트 */
    defaultStartLabel: '체크인',

    /** 종료일이 없을 때 인풋에 보여줄 기본 텍스트 */
    defaultEndLabel: '체크아웃',


    // --- [3] 날짜 제한 (Constraints) ---

    /** * 선택 가능한 최소 날짜
     * 값: 'today' (오늘부터), '2025-11-01' (특정일), null (제한 없음)
     * 기본값: 'today'
     */
    minDate: 'today',

    /** * 선택 가능한 최대 날짜
     * 값: '2026-12-31' (특정일), null (제한 없음)
     */
    maxDate: '2026-06-30',

    /** * 오늘(혹은 minDate)을 기준으로 선택 가능한 최대 기간(일수)
     * 예: 90 (오늘부터 90일 뒤까지만 선택 가능)
     * 설정 시 maxDate보다 우선순위가 높거나 더 좁은 범위가 적용됨
     */
    selectableDays: 90,

    /** * 특정 날짜 비활성화 (Blacklist) - 휴무일 등
     * 배열 안에 'YYYY-MM-DD' 형식으로 입력
     */
    disable: ['2025-12-25', '2026-01-01'],

    /** * 특정 날짜만 활성화 (Whitelist) - 예약 가능일 등
     * 이 값이 있으면 disable은 무시됨
     */
    // enable: ['2025-12-10', '2025-12-11'], 


    // --- [4] 초기 값 설정 (Initial Values) ---
    
    /** * 초기 시작일/종료일 강제 설정
     * (HTML Input의 value보다 우선순위가 높음)
     */
    startDate: '2025-12-24',
    endDate: '2025-12-26',


    // --- [5] 스타일링 ---

    /** * 선택된 기간의 배경(td)에 추가할 사용자 정의 CSS 클래스
     * (CSS 파일에 .my-custom-gradient { ... } 정의 필요)
     */
    rangeClass: 'my-custom-gradient',


    // --- [6] 이벤트 콜백 (Callbacks) ---

    /** 날짜 선택이 완료되었을 때 (클릭 시) */
    onSelect: function(value) {
        console.log('선택됨:', value.startDate, '~', value.endDate);
    },

    /** * 달력이 그려질 때 각 날짜 셀(td/button) 커스텀
     * 예: 가격 표시, 아이콘 추가
     */
    onRenderCell: function(date, cellElement) {
        // 1일마다 빨간 점 찍기 예시
        if (date.getDate() === 1) {
            cellElement.style.border = '1px solid red';
        }
    },

    /** 스와이프 모드에서 달력 페이지가 변경됐을 때 */
    onMonthChange: function(year, month) {
        console.log('현재 보고 있는 달:', year, month);
    },

    /** 비활성화된 날짜를 클릭했을 때 경고 */
    onInvalid: function(dateStr) {
        alert(dateStr + "은 선택할 수 없습니다.");
    },

    /** 초기화가 완료되었을 때 */
    onInit: function(instance) {
        console.log('캘린더 로딩 완료');
    },

    /** destroy() 호출 시 */
    onDestroy: function() {
        console.log('캘린더 삭제됨');
    }
});
-->
</body>
</html>
