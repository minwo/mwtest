function CalendarLib(element, options) {

        if (!element) {

            console.error("CalendarLib: Error - Element not found");

            return;

        }

        this.element = element;

        options = options || {};

        

        var defaultDayNames = ['일', '월', '화', '수', '목', '금', '토'];



        this.options = {

            numberOfMonths: options.numberOfMonths, 

            selectionMode: options.selectionMode || 'RANGE',

            startDateSelector: options.startDateSelector || null, 

            endDateSelector: options.endDateSelector || null, 

            format: options.format || 'YYYY.MM.DD(ddd)', 

            defaultStartLabel: options.defaultStartLabel || '가는날', 

            defaultEndLabel: options.defaultEndLabel || '오는날',

            dayNames: options.dayNames || defaultDayNames,

            monthHeaderFormat: options.monthHeaderFormat || 'YYYY년 M월',

            

            swipeNavigation: options.swipeNavigation || false, 

            rangeClass: options.rangeClass || null,

            

            disable: options.disable || [], 

            enable: options.enable || [],

            startDate: options.startDate || null, 

            endDate: options.endDate || null,

            selectableDays: options.selectableDays || null, 

            minDate: options.minDate !== undefined ? options.minDate : 'today', 

            maxDate: options.maxDate || null,

            

            // Event Callbacks

            onSelect: options.onSelect || null, 

            onInvalid: options.onInvalid || null, 

            onMonthChange: options.onMonthChange || null, 

            onRenderCell: options.onRenderCell || null

        };

        

        this.els = {

            startInput: this.options.startDateSelector ? document.querySelector(this.options.startDateSelector) : null,

            endInput: (this.options.selectionMode === 'RANGE' && this.options.endDateSelector) ? document.querySelector(this.options.endDateSelector) : null

        };

        

        this.isSingleMode = (this.options.selectionMode === 'SINGLE');

        this.startDate = null; 

        this.endDate = null;

        this.today = new Date(); 

        this.today.setHours(0, 0, 0, 0);

        this.minLimit = null; 

        this.maxLimit = null;

        

        this.allDayBtns = []; 

        this.cachedMarkerTds = [];

        this.monthData = []; 

        this.currentMonthIndex = 0; 

        this.isEventBound = false;



        this.init();

    }



    CalendarLib.prototype.init = function() {

        // 1. 초기값 파싱 (옵션 > 인풋)

        var initialStartISO = null;

        var initialEndISO = null;



        // Start Date

        if (this.options.startDate) {

            initialStartISO = this._parseDisplayDate(this.options.startDate);

        } else if (this.els.startInput && this.els.startInput.value) {

            initialStartISO = this._parseDisplayDate(this.els.startInput.value);

        }



        // End Date

        if (!this.isSingleMode) {

            if (this.options.endDate) {

                initialEndISO = this._parseDisplayDate(this.options.endDate);

            } else if (this.els.endInput && this.els.endInput.value) {

                initialEndISO = this._parseDisplayDate(this.els.endInput.value);

            }

        }



        // 2. Min/Max Limit 설정

        if (this.options.minDate === 'today') { 

            this.minLimit = new Date(this.today.getTime()); 

        } else if (this.options.minDate) { 

            this.minLimit = this._parseDate(this._parseDisplayDate(this.options.minDate)); 

        } else { 

            this.minLimit = null; 

        }



        if (typeof this.options.selectableDays === 'number' && this.options.selectableDays > 0) {

            var baseDate = this.minLimit ? new Date(this.minLimit.getTime()) : new Date(this.today.getTime());

            this.maxLimit = new Date(baseDate.getTime());

            this.maxLimit.setDate(this.maxLimit.getDate() + this.options.selectableDays - 1);

        } else if (this.options.maxDate) {

            this.maxLimit = this._parseDate(this._parseDisplayDate(this.options.maxDate));

        }



        if (this.minLimit) this.minLimit.setHours(0,0,0,0);

        if (this.maxLimit) this.maxLimit.setHours(0,0,0,0);



        // 3. 렌더링 기준일 계산 (MinDate 최우선)

        var startObj = initialStartISO ? this._parseDate(initialStartISO) : null;

        var renderBaseDate;

        

        if (this.minLimit) {

            // 1순위: MinDate가 있으면 무조건 MinDate 월부터

            renderBaseDate = new Date(this.minLimit.getTime());

        } else if (startObj) {

            // 2순위: MinDate 없고 시작일 있으면 시작일 기준

            renderBaseDate = new Date(startObj.getTime());

        } else {

            // 3순위: 다 없으면 오늘

            renderBaseDate = new Date(this.today.getTime());

        }



        var startYear = renderBaseDate.getFullYear();

        var startMonth = renderBaseDate.getMonth() + 1;



        // 4. numberOfMonths 자동 계산

        if (!this.options.numberOfMonths) {

            var neededMonths = 1; // 기본값 1달

            

            // MaxLimit이 있으면 거기까지

            var targetDate = this.maxLimit;

            

            // MaxLimit이 없으면 선택된 종료일(또는 시작일)까지 확장

            if (!targetDate) {

                if (initialEndISO) targetDate = this._parseDate(initialEndISO);

                else if (initialStartISO) targetDate = this._parseDate(initialStartISO);

            }



            if (targetDate) {

                var diff = (targetDate.getFullYear() * 12 + targetDate.getMonth()) - 

                           (startYear * 12 + (startMonth - 1)) + 1;

                neededMonths = Math.max(neededMonths, diff);

            }

            this.options.numberOfMonths = neededMonths;

        }



        // 5. UI 생성

        this.element.innerHTML = '';

        if (this.options.swipeNavigation) { 

            this._buildSwipeStructure(startYear, startMonth); 

            this.currentMonthIndex = 0; 

        } else { 

            this._buildScrollStructure(startYear, startMonth); 

        }



        // 6. DOM 캐싱

        this.allDayBtns = this.element.querySelectorAll('.day-btn');

        this.cachedMarkerTds = this.element.querySelectorAll('[data-marker-type]');



        // 7. 이벤트 바인딩 (중복 방지)

        if (!this.isEventBound) {

            this.element.removeEventListener('click', this._handleDayClick);

            this.element.addEventListener('click', this._handleDayClick.bind(this));

            this.isEventBound = true;

        }

        

        // 8. 초기 선택 적용

        this.setRange(initialStartISO, initialEndISO);

        this._triggerRenderCell();

    };



    CalendarLib.prototype._triggerRenderCell = function() {

        if (typeof this.options.onRenderCell === 'function') {

            for (var i = 0; i < this.allDayBtns.length; i++) {

                var btn = this.allDayBtns[i];

                var d = this._parseDate(btn.dataset.date);

                this.options.onRenderCell(d, btn.parentNode);

            }

        }

    };



    CalendarLib.prototype._isDateDisabled = function(dateObj, dateStr) {

        if (this.minLimit && dateObj.getTime() < this.minLimit.getTime()) return true;

        if (this.maxLimit && dateObj.getTime() > this.maxLimit.getTime()) return true;

        if (this.options.enable && this.options.enable.length > 0) return this.options.enable.indexOf(dateStr) === -1;

        if (this.options.disable && this.options.disable.length > 0) return this.options.disable.indexOf(dateStr) !== -1;

        return false;

    };



    // [Clean HTML] 스타일 클래스 제거됨

    CalendarLib.prototype._generateCalendarHTML = function(year, month) {

        var monthIndex = month - 1; var firstDay = new Date(year, monthIndex, 1);

        var daysInMonth = new Date(year, month, 0).getDate();

        var startDayOfWeek = firstDay.getDay(); 

        

        var monthTitle = this.options.monthHeaderFormat

            .replace('YYYY', year)

            .replace('M', month)

            .replace('MM', (month < 10 ? '0'+month : month));



        var html = '<div class="month-grid">' + 

            '<h3 id="month-'+year+'-'+month+'">' + monthTitle + '</h3>' +

            '<table role="grid" aria-labelledby="month-'+year+'-'+month+'">' +

                '<thead><tr>';

        

        for (var d = 0; d < 7; d++) {

            var thClass = (d === 0) ? 'is-sun' : '';

            html += '<th scope="col" class="' + thClass + '">' + this.options.dayNames[d] + '</th>';

        }

        html += '</tr></thead><tbody>';

            

        var dayCounter = 1; var paddingStarted = false;

        

        var firstDayOfCurrentMonth = new Date(year, monthIndex, 1); firstDayOfCurrentMonth.setHours(0,0,0,0);

        var lastDayOfCurrentMonth = new Date(year, monthIndex, daysInMonth); lastDayOfCurrentMonth.setHours(0,0,0,0);

        var firstDayISO = this._dateToISO(firstDayOfCurrentMonth);

        var lastDayISO = this._dateToISO(lastDayOfCurrentMonth);



        for (var i = 0; i < 6; i++) {

            html += '<tr>';

            for (var j = 0; j < 7; j++) {

                var tdClasses = ''; var classes = 'day-btn'; var extraLabel = ''; var ariaLabel = '';

                var markerAttr = '';



                if (i === 0 && j < startDayOfWeek) { 

                    if (j === startDayOfWeek - 1) { 

                        markerAttr = 'data-marker-type="prev" data-ref-date="' + firstDayISO + '"'; 

                    }

                    html += '<td class="' + tdClasses + '" ' + markerAttr + '><span aria-hidden="true"></span></td>'; 

                    continue;

                } else if (dayCounter > daysInMonth) {

                    if (!paddingStarted) { 

                        markerAttr = 'data-marker-type="next" data-ref-date="' + lastDayISO + '"'; 

                        paddingStarted = true; 

                    }

                    html += '<td class="' + tdClasses + '" ' + markerAttr + '><span aria-hidden="true"></span></td>'; 

                    dayCounter++; 

                    continue;

                } else {

                    var dateObj = new Date(year, monthIndex, dayCounter); 

                    dateObj.setHours(0,0,0,0);

                    var fullDateStr = this._dateToISO(dateObj);

                    ariaLabel = year + '년 ' + month + '월 ' + dayCounter + '일';



                    if (j === 0) classes += ' is-sun';

                    if (dateObj.getTime() === this.today.getTime()) { 

                        classes += ' is-today'; 

                        extraLabel = '<span class="today-label" aria-hidden="true">오늘</span>';

                    }

                    

                    var isDisabled = this._isDateDisabled(dateObj, fullDateStr);

                    var disabledAttr = isDisabled ? 'disabled aria-disabled="true"' : '';

                    

                    if (isDisabled) { 

                        tdClasses += ' is-disabled'; 

                        classes += ' is-disabled'; 

                    }

                    

                    html += '<td class="' + tdClasses + '"><button type="button" class="' + classes + '" data-date="' + fullDateStr + '" aria-label="' + ariaLabel + '" ' + disabledAttr + '>' + dayCounter + extraLabel + '</button></td>';

                    dayCounter++;

                }

            }

            html += '</tr>';

            if (dayCounter > daysInMonth) break; 

        }

        html += '</tbody></table></div>';

        return html;

    };



    CalendarLib.prototype.setRange = function(start, endOrDuration) {

        var endOr = endOrDuration !== undefined ? endOrDuration : null; 

        this.startDate = start || null; this.endDate = null;

        

        if (this.isSingleMode) {

            // SINGLE

        } else if (this.startDate) {

            // RANGE

            if (typeof endOr === 'string') { 

                this.endDate = endOr; 

            } else if (typeof endOr === 'number') {

                var date = this._parseDate(this.startDate); 

                if (date) { 

                    date.setDate(date.getDate() + endOr); 

                    this.endDate = this._dateToISO(date); 

                }

            }

            // 유효성 검사

            if (this.endDate) {

                var s = this._parseDate(this.startDate); 

                var e = this._parseDate(this.endDate);

                s.setHours(0,0,0,0); e.setHours(0,0,0,0);

                if (e.getTime() <= s.getTime()) { this.endDate = null; }

            }

        } 

        this._updateUI();

    };



    CalendarLib.prototype._handleDayClick = function(e) {

        var target = e.target;

        var btn = target.closest('.day-btn');

        

        if (!btn) return; 

        if (btn.disabled) {

             if(typeof this.options.onInvalid === 'function') { 

                 this.options.onInvalid(btn.dataset.date); 

             }

             return; 

        }

        

        var clickedDate = btn.dataset.date;

        

        if (this.isSingleMode) {

            this.startDate = clickedDate; 

            this.endDate = null;

        } else {

            if (this.startDate && this.endDate) { 

                this.startDate = clickedDate; 

                this.endDate = null; 

            } else if (this.startDate && !this.endDate) {

                var sDate = this._parseDate(this.startDate);

                var cDate = this._parseDate(clickedDate);

                if (cDate.getTime() <= sDate.getTime()) {

                    this.startDate = clickedDate; 

                    this.endDate = null; 

                } else { 

                    this.endDate = clickedDate; 

                }

            } else { 

                this.startDate = clickedDate; 

            }

        }

        

        this._updateUI();

        

        // [확인됨] onSelect 이벤트 호출

        if(typeof this.options.onSelect === 'function') { 

            this.options.onSelect(this.getValue()); 

        }

    };



    CalendarLib.prototype._updateUI = function() {

        var start = this.startDate ? this._parseDate(this.startDate) : null; 

        var end = this.endDate ? this._parseDate(this.endDate) : null; 

        var customClass = this.options.rangeClass;

        

        var allBtns = (this.allDayBtns && this.allDayBtns.length > 0) ? this.allDayBtns : this.element.querySelectorAll('.day-btn');

        

        for (var i = 0; i < allBtns.length; i++) {

            var btn = allBtns[i]; 

            var dayDateStr = btn.dataset.date; if (!dayDateStr) continue;

            var dayDate = this._parseDate(dayDateStr); var dayCell = btn.parentNode; 

            

            btn.setAttribute('aria-selected', 'false'); 

            dayCell.classList.remove('is-in-range', 'is-range-start', 'is-range-end', 'is-start-date', 'is-end-date', 'is-single-date');

            if (customClass) { dayCell.classList.remove(customClass); }



            if (dayDate.getTime() === this.today.getTime()) { btn.setAttribute('aria-current', 'date'); }



            if (this.isSingleMode) {

                if (this.startDate === dayDateStr) { 

                    dayCell.classList.add('is-single-date'); btn.setAttribute('aria-selected', 'true');

                }

            } else {

                if (start && end) {

                    if (dayDate > start && dayDate < end) { 

                        dayCell.classList.add('is-in-range'); 

                        if (customClass) { dayCell.classList.add(customClass); }

                    }

                }

                if (dayDateStr === this.startDate) { 

                    dayCell.classList.add('is-start-date'); btn.setAttribute('aria-selected', 'true'); 

                    if (end) { dayCell.classList.add('is-range-start'); } 

                } 

                if (dayDateStr === this.endDate) { 

                    dayCell.classList.add('is-end-date'); btn.setAttribute('aria-selected', 'true'); 

                    if (start) { dayCell.classList.add('is-range-end'); }

                }

            }

        } 



        var markerTds = (this.cachedMarkerTds && this.cachedMarkerTds.length > 0) ? this.cachedMarkerTds : this.element.querySelectorAll('[data-marker-type]');

        for (var k = 0; k < markerTds.length; k++) {

            var markerTd = markerTds[k];

            var type = markerTd.dataset.markerType; 

            var refDate = this._parseDate(markerTd.dataset.refDate);

            

            markerTd.classList.remove('range-start-marker', 'range-end-marker');



            if (start && end) {

                if (type === 'prev') {

                    if (start.getTime() < refDate.getTime() && end.getTime() >= refDate.getTime()) {

                        markerTd.classList.add('range-start-marker');

                    }

                } else if (type === 'next') {

                    if (start.getTime() <= refDate.getTime() && end.getTime() > refDate.getTime()) {

                        markerTd.classList.add('range-end-marker');

                    }

                }

            }

        }

        this._updateSelectorDisplays();

        this._dispatchChangeEvent();

    };



    CalendarLib.prototype._updateSelectorDisplays = function() {

        var fmt = this.options.format; 

        var sLab = this.options.defaultStartLabel; 

        var eLab = this.options.defaultEndLabel;

        

        var setVal = function(el, val, defaultText) {

            if (!el) return;

            var display = val ? this._formatDate(val, fmt) : defaultText;

            if (el.tagName === 'INPUT') { el.value = display; } 

            else { el.textContent = display; }

        }.bind(this);



        setVal(this.els.startInput, this.startDate, (this.isSingleMode ? '날짜 선택' : sLab));

        if (!this.isSingleMode) { setVal(this.els.endInput, this.endDate, eLab); }

    };



    // --- Helpers ---

    CalendarLib.prototype.getValue = function() { 

        var s = this.startDate ? this._formatDate(this.startDate, this.options.format) : null;

        var e = this.endDate ? this._formatDate(this.endDate, this.options.format) : null;

        return { startDate: s, endDate: e }; 

    };

    

    CalendarLib.prototype._dispatchChangeEvent = function() {

        var event; 

        var params = { detail: this.getValue(), bubbles: true, cancelable: true };

        try { 

            event = new CustomEvent('calendar-change', params); 

        } catch (e) { 

            event = document.createEvent('CustomEvent'); 

            event.initCustomEvent('calendar-change', true, true, this.getValue()); 

        }

        this.element.dispatchEvent(event);

    };



    CalendarLib.prototype._parseDisplayDate = function(dateString) { 

        if (!dateString) return null; 

        var cleanDate = dateString.split('(')[0].trim().replace(/[\.\/]/g, '-'); 

        return /^\d{4}-\d{1,2}-\d{1,2}$/.test(cleanDate) ? cleanDate : null; 

    };



    CalendarLib.prototype._formatDate = function(dateString, formatString) {

        if (!dateString || !formatString) return null; 

        var date = this._parseDate(dateString); 

        if (!date) return null;

        var y = date.getFullYear(), m = date.getMonth() + 1, d = date.getDate(), dayIdx = date.getDay();

        var tokens = { YYYY: y, MM: m<10?'0'+m:m, M: m, DD: d<10?'0'+d:d, D: d, ddd: this.options.dayNames[dayIdx] };

        return formatString.replace(/YYYY|MM|M|DD|D|ddd/g, function(x) { return tokens[x] || x; });

    };



    CalendarLib.prototype._parseDate = function(str) { 

        if (!str) return null; var p = str.split('-'); 

        return new Date(p[0], p[1]-1, p[2]); 

    };



    CalendarLib.prototype._dateToISO = function(d) { 

        if(!d) return null; var m = d.getMonth()+1, day = d.getDate(); 

        return d.getFullYear() + '-' + (m<10?'0'+m:m) + '-' + (day<10?'0'+day:day); 

    };

    

    CalendarLib.prototype._buildSwipeStructure = function(startYear, startMonth) {

        var current = new Date(startYear, startMonth - 1, 1); 

        this.monthData = [];

        for (var i = 0; i < this.options.numberOfMonths; i++) { 

            this.monthData.push({ year: current.getFullYear(), month: current.getMonth() + 1 }); 

            current.setMonth(current.getMonth() + 1); 

        }

        var navHtml = '<div class="calendar-header"><button class="nav-prev nav-btn" aria-label="이전 달">&lt;</button><h3 class="month-title" aria-live="polite"></h3><button class="nav-next nav-btn" aria-label="다음 달">&gt;</button></div>';

        this.element.innerHTML += navHtml;

        var viewport = document.createElement('div'); viewport.className = 'calendar-viewport overflow-hidden relative';

        var slider = document.createElement('div'); slider.className = 'calendar-slider flex';

        for (var i = 0; i < this.monthData.length; i++) {

            var m = this.monthData[i]; 

            var html = this._generateCalendarHTML(m.year, m.month);

            var wrap = document.createElement('div'); wrap.className = 'month-container min-w-full'; 

            var tempDiv = document.createElement('div'); tempDiv.innerHTML = html;

            if(tempDiv.querySelector('h3')) tempDiv.querySelector('h3').remove();

            wrap.innerHTML = tempDiv.innerHTML; 

            slider.appendChild(wrap);

        }

        viewport.appendChild(slider); this.element.appendChild(viewport); this._bindSwipeEvents(); this._updateNavigationTitle();

    };



    CalendarLib.prototype._buildScrollStructure = function(startYear, startMonth) {

        var current = new Date(startYear, startMonth - 1, 1); 

        var container = document.createElement('div'); 

        container.className = 'calendar-scroll-container space-y-4 max-h-[50vh] overflow-y-auto';

        for (var i = 0; i < this.options.numberOfMonths; i++) { 

            container.innerHTML += this._generateCalendarHTML(current.getFullYear(), current.getMonth() + 1); 

            current.setMonth(current.getMonth() + 1); 

        }

        this.element.appendChild(container);

    };



    CalendarLib.prototype._bindSwipeEvents = function() {

        var self = this; 

        var prevBtn = this.element.querySelector('.nav-prev'); 

        var nextBtn = this.element.querySelector('.nav-next');

        prevBtn.addEventListener('click', function() { self._handleNavClick(-1); }); 

        nextBtn.addEventListener('click', function() { self._handleNavClick(1); });

    };



    CalendarLib.prototype._handleNavClick = function(dir) {

        var next = this.currentMonthIndex + dir; 

        if (next >= 0 && next < this.monthData.length) { 

            this.currentMonthIndex = next; 

            this._animateSwipe(); 

            this._updateNavigationTitle(); 

            if(this.options.onMonthChange) this.options.onMonthChange(this.monthData[next].year, this.monthData[next].month); 

        }

    };



    CalendarLib.prototype._animateSwipe = function() { 

        this.element.querySelector('.calendar-slider').style.transform = 'translateX(' + (-100 * this.currentMonthIndex) + '%)'; 

    };



    CalendarLib.prototype._updateNavigationTitle = function() {

        var m = this.monthData[this.currentMonthIndex]; 

        var title = this.options.monthHeaderFormat.replace('YYYY', m.year).replace('M', m.month).replace('MM', (m.month<10?'0'+m.month:m.month));

        this.element.querySelector('.month-title').textContent = title;

        var p = this.element.querySelector('.nav-prev'), n = this.element.querySelector('.nav-next');

        p.disabled = this.currentMonthIndex===0; 

        n.disabled = this.currentMonthIndex===this.monthData.length-1; 

    };

single 옵션을 적용했을 때 swiper 옵션 true이고 선택 된 달로 달력이 스와이프 되어 열리게 로직 추가해주고 

range swiper true 일때는 시작일 기준으로 스와이프 되게 로직 추가해줘
